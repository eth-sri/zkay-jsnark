/*******************************************************************************
 * Gadget to perform ECDH with my secret key and other public key,
 * based on jsnark's ECDH gadget
 * Author: Nick Baumann
 *******************************************************************************/
package zkay;

import circuit.eval.CircuitEvaluator;
import circuit.eval.Instruction;
import circuit.structure.ConstantWire;
import circuit.structure.Wire;

import java.math.BigInteger;

/**
 * Shared key computation part of jsnark's ECDHKeyExchangeGadget
 */

public class ZkayECDHGadget extends ZkayEcGadget {

    // The Affine point representation is used as it saves one gate per bit
    private final AffinePoint hPoint; // H is the other party's public value
    // H = (other party's secret)* Base <- scalar EC
    // multiplication

    private final Wire[] secretBits; // the bits of the secret generated by this party
    // (follows little-endian order)

    // gadget output
    private Wire sharedSecret; // the x-coordinate of the derived key ((this
    // party's secret)*H).x

    private AffinePoint[] hTable;

    public ZkayECDHGadget(Wire hX, Wire secretKey, boolean validateSecret, String... desc) {
        super(desc);
        this.secretBits = secretKey.getBitWires(SECRET_BITWIDTH).asArray();
        this.hPoint = new AffinePoint(hX);
        if (validateSecret) {
            checkSecretBits(generator, secretBits);
        }
        computeYCoordinates(); // For efficiency reasons, we rely on affine
        // coordinates
        buildCircuit();
    }

    protected void buildCircuit() {
        /**
         * The reason this operates on affine coordinates is that in our
         * setting, this's slightly cheaper than the formulas in
         * https://cr.yp.to/ecdh/curve25519-20060209.pdf. Concretely, the
         * following equations save 1 multiplication gate per bit. (we consider
         * multiplications by constants cheaper in our setting, so they are not
         * counted)
         */

        hTable = preprocess(hPoint);
        sharedSecret = mul(hPoint, secretBits, hTable).x;
    }

    private void computeYCoordinates() {
        // Easy to handle if hPoint is constant, otherwise, let the prover input
        // a witness and verify some properties

        if (hPoint.x instanceof ConstantWire) {
            BigInteger x = ((ConstantWire) hPoint.x).getConstant();
            hPoint.y = generator.createConstantWire(computeYCoordinate(x));
        } else {
            hPoint.y = generator.createProverWitnessWire();
            generator.specifyProverWitnessComputation(new Instruction() {
                public void evaluate(CircuitEvaluator evaluator) {
                    BigInteger x = evaluator.getWireValue(hPoint.x);
                    evaluator.setWireValue(hPoint.y, computeYCoordinate(x));
                }
            });
            assertValidPointOnEC(hPoint.x, hPoint.y);
        }
    }

    @Override
    public Wire[] getOutputWires() {
        Wire sharedKey = new ZkaySHA256Gadget(new Wire[]{sharedSecret}, 128).getOutputWires()[0];
        return new Wire[] { sharedKey };
    }

    public void validateInputs() {
        generator.addOneAssertion(hPoint.x.checkNonZero());
        assertValidPointOnEC(hPoint.x, hPoint.y);
        assertPointOrder(hPoint, hTable);
    }
}
